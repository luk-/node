{
  "source": "doc/api/stream.markdown",
  "modules": [
    {
      "textRaw": "Stream",
      "name": "stream",
      "stability": 2,
      "stabilityText": "Unstable",
      "desc": "<p>A stream is an abstract interface implemented by various objects in\nNode.  For example a request to an HTTP server is a stream, as is\nstdout. Streams are readable, writable, or both. All streams are\ninstances of [EventEmitter][]\n\n</p>\n<p>You can load the Stream base classes by doing <code>require(&#39;stream&#39;)</code>.\nThere are base classes provided for Readable streams, Writable\nstreams, Duplex streams, and Transform streams.\n\n</p>\n",
      "modules": [
        {
          "textRaw": "Compatibility",
          "name": "compatibility",
          "desc": "<p>In earlier versions of Node, the Readable stream interface was\nsimpler, but also less powerful and less useful.\n\n</p>\n<ul>\n<li>Rather than waiting for you to call the <code>read()</code> method, <code>&#39;data&#39;</code>\nevents would start emitting immediately.  If you needed to do some\nI/O to decide how to handle data, then you had to store the chunks\nin some kind of buffer so that they would not be lost.</li>\n<li>The <code>pause()</code> method was advisory, rather than guaranteed.  This\nmeant that you still had to be prepared to receive <code>&#39;data&#39;</code> events\neven when the stream was in a paused state.</li>\n</ul>\n<p>In Node v0.10, the Readable class described below was added.  For\nbackwards compatibility with older Node programs, Readable streams\nswitch into &quot;old mode&quot; when a <code>&#39;data&#39;</code> event handler is added, or when\nthe <code>pause()</code> or <code>resume()</code> methods are called.  The effect is that,\neven if you are not using the new <code>read()</code> method and <code>&#39;readable&#39;</code>\nevent, you no longer have to worry about losing <code>&#39;data&#39;</code> chunks.\n\n</p>\n<p>Most programs will continue to function normally.  However, this\nintroduces an edge case in the following conditions:\n\n</p>\n<ul>\n<li>No <code>&#39;data&#39;</code> event handler is added.</li>\n<li>The <code>pause()</code> and <code>resume()</code> methods are never called.</li>\n</ul>\n<p>For example, consider the following code:\n\n</p>\n<pre><code class=\"javascript\">// WARNING!  BROKEN!\nnet.createServer(function(socket) {\n\n  // we add an &#39;end&#39; method, but never consume the data\n  socket.on(&#39;end&#39;, function() {\n    // It will never get here.\n    socket.end(&#39;I got your message (but didnt read it)\\n&#39;);\n  });\n\n}).listen(1337);</code></pre>\n<p>In versions of node prior to v0.10, the incoming message data would be\nsimply discarded.  However, in Node v0.10 and beyond, the socket will\nremain paused forever.\n\n</p>\n<p>The workaround in this situation is to call the <code>resume()</code> method to\ntrigger &quot;old mode&quot; behavior:\n\n</p>\n<pre><code class=\"javascript\">// Workaround\nnet.createServer(function(socket) {\n\n  socket.on(&#39;end&#39;, function() {\n    socket.end(&#39;I got your message (but didnt read it)\\n&#39;);\n  });\n\n  // start the flow of data, discarding it.\n  socket.resume();\n\n}).listen(1337);</code></pre>\n<p>In addition to new Readable streams switching into old-mode, pre-v0.10\nstyle streams can be wrapped in a Readable class using the <code>wrap()</code>\nmethod.\n\n</p>\n",
          "type": "module",
          "displayName": "Compatibility"
        }
      ],
      "classes": [
        {
          "textRaw": "Class: stream.Readable",
          "type": "class",
          "name": "stream.Readable",
          "desc": "<p>A <code>Readable Stream</code> has the following methods, members, and events.\n\n</p>\n<p>Note that <code>stream.Readable</code> is an abstract class designed to be\nextended with an underlying implementation of the <code>_read(size, cb)</code>\nmethod. (See below.)\n\n</p>\n",
          "methods": [
            {
              "textRaw": "new stream.Readable([options])",
              "type": "method",
              "name": "Readable",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`options` {Object} ",
                      "options": [
                        {
                          "textRaw": "`bufferSize` {Number} The size of the chunks to consume from the underlying resource. Default=16kb ",
                          "name": "bufferSize",
                          "type": "Number",
                          "desc": "The size of the chunks to consume from the underlying resource. Default=16kb"
                        },
                        {
                          "textRaw": "`lowWaterMark` {Number} The minimum number of bytes to store in the internal buffer before emitting `readable`.  Default=0 ",
                          "name": "lowWaterMark",
                          "type": "Number",
                          "desc": "The minimum number of bytes to store in the internal buffer before emitting `readable`.  Default=0"
                        },
                        {
                          "textRaw": "`highWaterMark` {Number} The maximum number of bytes to store in the internal buffer before ceasing to read from the underlying resource.  Default=16kb ",
                          "name": "highWaterMark",
                          "type": "Number",
                          "desc": "The maximum number of bytes to store in the internal buffer before ceasing to read from the underlying resource.  Default=16kb"
                        },
                        {
                          "textRaw": "`encoding` {String} If specified, then buffers will be decoded to strings using the specified encoding.  Default=null ",
                          "name": "encoding",
                          "type": "String",
                          "desc": "If specified, then buffers will be decoded to strings using the specified encoding.  Default=null"
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>In classes that extend the Readable class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n</p>\n"
            },
            {
              "textRaw": "readable.\\_read(size, callback)",
              "type": "method",
              "name": "\\_read",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`size` {Number} Number of bytes to read asynchronously ",
                      "name": "size",
                      "type": "Number",
                      "desc": "Number of bytes to read asynchronously"
                    },
                    {
                      "textRaw": "`callback` {Function} Called with an error or with data ",
                      "name": "callback",
                      "type": "Function",
                      "desc": "Called with an error or with data"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "size"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ],
              "desc": "<p>All Readable stream implementations must provide a <code>_read</code> method\nto fetch data from the underlying resource.\n\n</p>\n<p>Note: <strong>This function MUST NOT be called directly.</strong>  It should be\nimplemented by child classes, and called by the internal Readable\nclass methods only.\n\n</p>\n<p>Call the callback using the standard <code>callback(error, data)</code> pattern.\nWhen no more data can be fetched, call <code>callback(null, null)</code> to\nsignal the EOF.\n\n</p>\n<p>This method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you <strong>are</strong> expected to override this method in\nyour own extension classes.\n\n\n</p>\n"
            },
            {
              "textRaw": "readable.wrap(stream)",
              "type": "method",
              "name": "wrap",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`stream` {Stream} An \"old style\" readable stream ",
                      "name": "stream",
                      "type": "Stream",
                      "desc": "An \"old style\" readable stream"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "stream"
                    }
                  ]
                }
              ],
              "desc": "<p>If you are using an older Node library that emits <code>&#39;data&#39;</code> events and\nhas a <code>pause()</code> method that is advisory only, then you can use the\n<code>wrap()</code> method to create a Readable stream that uses the old stream\nas its data source.\n\n</p>\n<p>For example:\n\n</p>\n<pre><code class=\"javascript\">var OldReader = require(&#39;./old-api-module.js&#39;).OldReader;\nvar oreader = new OldReader;\nvar Readable = require(&#39;stream&#39;).Readable;\nvar myReader = new Readable().wrap(oreader);\n\nmyReader.on(&#39;readable&#39;, function() {\n  myReader.read(); // etc.\n});</code></pre>\n"
            },
            {
              "textRaw": "readable.setEncoding(encoding)",
              "type": "method",
              "name": "setEncoding",
              "desc": "<p>Makes the <code>&#39;data&#39;</code> event emit a string instead of a <code>Buffer</code>. <code>encoding</code>\ncan be <code>&#39;utf8&#39;</code>, <code>&#39;utf16le&#39;</code> (<code>&#39;ucs2&#39;</code>), <code>&#39;ascii&#39;</code>, or <code>&#39;hex&#39;</code>.\n\n</p>\n<p>The encoding can also be set by specifying an <code>encoding</code> field to the\nconstructor.\n\n</p>\n",
              "signatures": [
                {
                  "params": [
                    {
                      "name": "encoding"
                    }
                  ]
                }
              ]
            },
            {
              "textRaw": "readable.read([size])",
              "type": "method",
              "name": "read",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Return: {Buffer | String | null} ",
                    "name": "return",
                    "type": "Buffer | String | null"
                  },
                  "params": [
                    {
                      "textRaw": "`size` {Number | null} Optional number of bytes to read. ",
                      "name": "size",
                      "type": "Number | null",
                      "desc": "Optional number of bytes to read.",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "size",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Call this method to consume data once the <code>&#39;readable&#39;</code> event is\nemitted.\n\n</p>\n<p>The <code>size</code> argument will set a minimum number of bytes that you are\ninterested in.  If not set, then the entire content of the internal\nbuffer is returned.\n\n</p>\n<p>If there is no data to consume, or if there are fewer bytes in the\ninternal buffer than the <code>size</code> argument, then <code>null</code> is returned, and\na future <code>&#39;readable&#39;</code> event will be emitted when more is available.\n\n</p>\n<p>Note that calling <code>stream.read(0)</code> will always return <code>null</code>, and will\ntrigger a refresh of the internal buffer, but otherwise be a no-op.\n\n</p>\n"
            },
            {
              "textRaw": "readable.pipe(destination, [options])",
              "type": "method",
              "name": "pipe",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`destination` {Writable Stream} ",
                      "name": "destination",
                      "type": "Writable Stream"
                    },
                    {
                      "textRaw": "`options` {Object} Optional ",
                      "options": [
                        {
                          "textRaw": "`end` {Boolean} Default=true ",
                          "name": "end",
                          "type": "Boolean",
                          "desc": "Default=true"
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "destination"
                    },
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Connects this readable stream to <code>destination</code> WriteStream. Incoming\ndata on this stream gets written to <code>destination</code>.  Properly manages\nback-pressure so that a slow destination will not be overwhelmed by a\nfast readable stream.\n\n</p>\n<p>This function returns the <code>destination</code> stream.\n\n</p>\n<p>For example, emulating the Unix <code>cat</code> command:\n\n</p>\n<pre><code>process.stdin.pipe(process.stdout);</code></pre>\n<p>By default <code>end()</code> is called on the destination when the source stream\nemits <code>end</code>, so that <code>destination</code> is no longer writable. Pass <code>{ end:\nfalse }</code> as <code>options</code> to keep the destination stream open.\n\n</p>\n<p>This keeps <code>writer</code> open so that &quot;Goodbye&quot; can be written at the\nend.\n\n</p>\n<pre><code>reader.pipe(writer, { end: false });\nreader.on(&quot;end&quot;, function() {\n  writer.end(&quot;Goodbye\\n&quot;);\n});</code></pre>\n<p>Note that <code>process.stderr</code> and <code>process.stdout</code> are never closed until\nthe process exits, regardless of the specified options.\n\n</p>\n"
            },
            {
              "textRaw": "readable.unpipe([destination])",
              "type": "method",
              "name": "unpipe",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`destination` {Writable Stream} Optional ",
                      "name": "destination",
                      "type": "Writable Stream",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "destination",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Undo a previously established <code>pipe()</code>.  If no destination is\nprovided, then all previously established pipes are removed.\n\n</p>\n"
            },
            {
              "textRaw": "readable.pause()",
              "type": "method",
              "name": "pause",
              "desc": "<p>Switches the readable stream into &quot;old mode&quot;, where data is emitted\nusing a <code>&#39;data&#39;</code> event rather than being buffered for consumption via\nthe <code>read()</code> method.\n\n</p>\n<p>Ceases the flow of data.  No <code>&#39;data&#39;</code> events are emitted while the\nstream is in a paused state.\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            },
            {
              "textRaw": "readable.resume()",
              "type": "method",
              "name": "resume",
              "desc": "<p>Switches the readable stream into &quot;old mode&quot;, where data is emitted\nusing a <code>&#39;data&#39;</code> event rather than being buffered for consumption via\nthe <code>read()</code> method.\n\n</p>\n<p>Resumes the incoming <code>&#39;data&#39;</code> events after a <code>pause()</code>.\n\n\n</p>\n",
              "signatures": [
                {
                  "params": []
                }
              ]
            }
          ],
          "events": [
            {
              "textRaw": "Event: 'readable'",
              "type": "event",
              "name": "readable",
              "desc": "<p>When there is data ready to be consumed, this event will fire.  The\nnumber of bytes that are required to be considered &quot;readable&quot; depends\non the <code>lowWaterMark</code> option set in the constructor.\n\n</p>\n<p>When this event emits, call the <code>read()</code> method to consume the data.\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'end'",
              "type": "event",
              "name": "end",
              "desc": "<p>Emitted when the stream has received an EOF (FIN in TCP terminology).\nIndicates that no more <code>&#39;data&#39;</code> events will happen. If the stream is\nalso writable, it may be possible to continue writing.\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'data'",
              "type": "event",
              "name": "data",
              "desc": "<p>The <code>&#39;data&#39;</code> event emits either a <code>Buffer</code> (by default) or a string if\n<code>setEncoding()</code> was used.\n\n</p>\n<p>Note that adding a <code>&#39;data&#39;</code> event listener will switch the Readable\nstream into &quot;old mode&quot;, where data is emitted as soon as it is\navailable, rather than waiting for you to call <code>read()</code> to consume it.\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'error'",
              "type": "event",
              "name": "error",
              "desc": "<p>Emitted if there was an error receiving data.\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "desc": "<p>Emitted when the underlying resource (for example, the backing file\ndescriptor) has been closed. Not all streams will emit this.\n\n</p>\n",
              "params": []
            }
          ]
        },
        {
          "textRaw": "Class: stream.Writable",
          "type": "class",
          "name": "stream.Writable",
          "desc": "<p>A <code>Writable</code> Stream has the following methods, members, and events.\n\n</p>\n<p>Note that <code>stream.Writable</code> is an abstract class designed to be\nextended with an underlying implementation of the <code>_write(chunk, cb)</code>\nmethod. (See below.)\n\n</p>\n",
          "methods": [
            {
              "textRaw": "new stream.Writable([options])",
              "type": "method",
              "name": "Writable",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`options` {Object} ",
                      "options": [
                        {
                          "textRaw": "`highWaterMark` {Number} Buffer level when `write()` starts returning false. Default=16kb ",
                          "name": "highWaterMark",
                          "type": "Number",
                          "desc": "Buffer level when `write()` starts returning false. Default=16kb"
                        },
                        {
                          "textRaw": "`lowWaterMark` {Number} The buffer level when `'drain'` is emitted.  Default=0 ",
                          "name": "lowWaterMark",
                          "type": "Number",
                          "desc": "The buffer level when `'drain'` is emitted.  Default=0"
                        },
                        {
                          "textRaw": "`decodeStrings` {Boolean} Whether or not to decode strings into Buffers before passing them to `_write()`.  Default=true ",
                          "name": "decodeStrings",
                          "type": "Boolean",
                          "desc": "Whether or not to decode strings into Buffers before passing them to `_write()`.  Default=true"
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>In classes that extend the Writable class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n</p>\n"
            },
            {
              "textRaw": "writable.\\_write(chunk, callback)",
              "type": "method",
              "name": "\\_write",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`chunk` {Buffer | Array} The data to be written ",
                      "name": "chunk",
                      "type": "Buffer | Array",
                      "desc": "The data to be written"
                    },
                    {
                      "textRaw": "`callback` {Function} Called with an error, or null when finished ",
                      "name": "callback",
                      "type": "Function",
                      "desc": "Called with an error, or null when finished"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "chunk"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ],
              "desc": "<p>All Writable stream implementations must provide a <code>_write</code> method to\nsend data to the underlying resource.\n\n</p>\n<p>Note: <strong>This function MUST NOT be called directly.</strong>  It should be\nimplemented by child classes, and called by the internal Writable\nclass methods only.\n\n</p>\n<p>Call the callback using the standard <code>callback(error)</code> pattern to\nsignal that the write completed successfully or with an error.\n\n</p>\n<p>If the <code>decodeStrings</code> flag is set in the constructor options, then\n<code>chunk</code> will be an array rather than a Buffer.  This is to support\nimplementations that have an optimized handling for certain string\ndata encodings.\n\n</p>\n<p>This method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you <strong>are</strong> expected to override this method in\nyour own extension classes.\n\n\n</p>\n"
            },
            {
              "textRaw": "writable.write(chunk, [encoding], [callback])",
              "type": "method",
              "name": "write",
              "signatures": [
                {
                  "return": {
                    "textRaw": "Returns {Boolean} ",
                    "name": "return",
                    "type": "Boolean"
                  },
                  "params": [
                    {
                      "textRaw": "`chunk` {Buffer | String} Data to be written ",
                      "name": "chunk",
                      "type": "Buffer | String",
                      "desc": "Data to be written"
                    },
                    {
                      "textRaw": "`encoding` {String} Optional.  If `chunk` is a string, then encoding defaults to `'utf8'` ",
                      "name": "encoding",
                      "type": "String",
                      "optional": true,
                      "desc": "If `chunk` is a string, then encoding defaults to `'utf8'`"
                    },
                    {
                      "textRaw": "`callback` {Function} Optional.  Called when this chunk is successfully written. ",
                      "name": "callback",
                      "type": "Function",
                      "optional": true,
                      "desc": "Called when this chunk is successfully written."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "chunk"
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    },
                    {
                      "name": "callback",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Writes <code>chunk</code> to the stream.  Returns <code>true</code> if the data has been\nflushed to the underlying resource.  Returns <code>false</code> to indicate that\nthe buffer is full, and the data will be sent out in the future. The\n<code>&#39;drain&#39;</code> event will indicate when the buffer is empty again.\n\n</p>\n<p>The specifics of when <code>write()</code> will return false, and when a\nsubsequent <code>&#39;drain&#39;</code> event will be emitted, are determined by the\n<code>highWaterMark</code> and <code>lowWaterMark</code> options provided to the\nconstructor.\n\n</p>\n"
            },
            {
              "textRaw": "writable.end([chunk], [encoding])",
              "type": "method",
              "name": "end",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`chunk` {Buffer | String} Optional final data to be written ",
                      "name": "chunk",
                      "type": "Buffer | String",
                      "desc": "Optional final data to be written",
                      "optional": true
                    },
                    {
                      "textRaw": "`encoding` {String} Optional.  If `chunk` is a string, then encoding defaults to `'utf8'` ",
                      "name": "encoding",
                      "type": "String",
                      "optional": true,
                      "desc": "If `chunk` is a string, then encoding defaults to `'utf8'`"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "chunk",
                      "optional": true
                    },
                    {
                      "name": "encoding",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>Call this method to signal the end of the data being written to the\nstream.\n\n</p>\n"
            }
          ],
          "events": [
            {
              "textRaw": "Event: 'drain'",
              "type": "event",
              "name": "drain",
              "desc": "<p>Emitted when the stream&#39;s write queue empties and it&#39;s safe to write\nwithout buffering again. Listen for it when <code>stream.write()</code> returns\n<code>false</code>.\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'close'",
              "type": "event",
              "name": "close",
              "desc": "<p>Emitted when the underlying resource (for example, the backing file\ndescriptor) has been closed. Not all streams will emit this.\n\n</p>\n",
              "params": []
            },
            {
              "textRaw": "Event: 'pipe'",
              "type": "event",
              "name": "pipe",
              "params": [],
              "desc": "<p>Emitted when the stream is passed to a readable stream&#39;s pipe method.\n\n</p>\n"
            },
            {
              "textRaw": "Event 'unpipe'",
              "type": "event",
              "name": "unpipe",
              "params": [],
              "desc": "<p>Emitted when a previously established <code>pipe()</code> is removed using the\nsource Readable stream&#39;s <code>unpipe()</code> method.\n\n</p>\n"
            }
          ]
        },
        {
          "textRaw": "Class: stream.Duplex",
          "type": "class",
          "name": "stream.Duplex",
          "desc": "<p>A &quot;duplex&quot; stream is one that is both Readable and Writable, such as a\nTCP socket connection.\n\n</p>\n<p>Note that <code>stream.Duplex</code> is an abstract class designed to be\nextended with an underlying implementation of the <code>_read(size, cb)</code>\nand <code>_write(chunk, callback)</code> methods as you would with a Readable or\nWritable stream class.\n\n</p>\n<p>Since JavaScript doesn&#39;t have multiple prototypal inheritance, this\nclass prototypally inherits from Readable, and then parasitically from\nWritable.  It is thus up to the user to implement both the lowlevel\n<code>_read(n,cb)</code> method as well as the lowlevel <code>_write(chunk,cb)</code> method\non extension duplex classes.\n\n</p>\n",
          "methods": [
            {
              "textRaw": "new stream.Duplex(options)",
              "type": "method",
              "name": "Duplex",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`options` {Object} Passed to both Writable and Readable constructors. Also has the following fields: ",
                      "options": [
                        {
                          "textRaw": "`allowHalfOpen` {Boolean} Default=true.  If set to `false`, then the stream will automatically end the readable side when the writable side ends and vice versa. ",
                          "name": "allowHalfOpen",
                          "type": "Boolean",
                          "desc": "Default=true.  If set to `false`, then the stream will automatically end the readable side when the writable side ends and vice versa."
                        }
                      ],
                      "name": "options",
                      "type": "Object",
                      "desc": "Passed to both Writable and Readable constructors. Also has the following fields:"
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "options"
                    }
                  ]
                }
              ],
              "desc": "<p>In classes that extend the Duplex class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n</p>\n"
            }
          ]
        },
        {
          "textRaw": "Class: stream.Transform",
          "type": "class",
          "name": "stream.Transform",
          "desc": "<p>A &quot;transform&quot; stream is a duplex stream where the output is causally\nconnected in some way to the input, such as a zlib stream or a crypto\nstream.\n\n</p>\n<p>There is no requirement that the output be the same size as the input,\nthe same number of chunks, or arrive at the same time.  For example, a\nHash stream will only ever have a single chunk of output which is\nprovided when the input is ended.  A zlib stream will either produce\nmuch smaller or much larger than its input.\n\n</p>\n<p>Rather than implement the <code>_read()</code> and <code>_write()</code> methods, Transform\nclasses must implement the <code>_transform()</code> method, and may optionally\nalso implement the <code>_flush()</code> method.  (See below.)\n\n</p>\n",
          "methods": [
            {
              "textRaw": "new stream.Transform([options])",
              "type": "method",
              "name": "Transform",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`options` {Object} Passed to both Writable and Readable constructors. ",
                      "name": "options",
                      "type": "Object",
                      "desc": "Passed to both Writable and Readable constructors.",
                      "optional": true
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "options",
                      "optional": true
                    }
                  ]
                }
              ],
              "desc": "<p>In classes that extend the Transform class, make sure to call the\nconstructor so that the buffering settings can be properly\ninitialized.\n\n</p>\n"
            },
            {
              "textRaw": "transform.\\_transform(chunk, outputFn, callback)",
              "type": "method",
              "name": "\\_transform",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`chunk` {Buffer} The chunk to be transformed. ",
                      "name": "chunk",
                      "type": "Buffer",
                      "desc": "The chunk to be transformed."
                    },
                    {
                      "textRaw": "`outputFn` {Function} Call this function with any output data to be passed to the readable interface. ",
                      "name": "outputFn",
                      "type": "Function",
                      "desc": "Call this function with any output data to be passed to the readable interface."
                    },
                    {
                      "textRaw": "`callback` {Function} Call this function (optionally with an error argument) when you are done processing the supplied chunk. ",
                      "name": "callback",
                      "type": "Function",
                      "desc": "Call this function (optionally with an error argument) when you are done processing the supplied chunk."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "chunk"
                    },
                    {
                      "name": "outputFn"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ],
              "desc": "<p>All Transform stream implementations must provide a <code>_transform</code>\nmethod to accept input and produce output.\n\n</p>\n<p>Note: <strong>This function MUST NOT be called directly.</strong>  It should be\nimplemented by child classes, and called by the internal Transform\nclass methods only.\n\n</p>\n<p><code>_transform</code> should do whatever has to be done in this specific\nTransform class, to handle the bytes being written, and pass them off\nto the readable portion of the interface.  Do asynchronous I/O,\nprocess things, and so on.\n\n</p>\n<p>Call the callback function only when the current chunk is completely\nconsumed.  Note that this may mean that you call the <code>outputFn</code> zero\nor more times, depending on how much data you want to output as a\nresult of this chunk.\n\n</p>\n<p>This method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you <strong>are</strong> expected to override this method in\nyour own extension classes.\n\n</p>\n"
            },
            {
              "textRaw": "transform.\\_flush(outputFn, callback)",
              "type": "method",
              "name": "\\_flush",
              "signatures": [
                {
                  "params": [
                    {
                      "textRaw": "`outputFn` {Function} Call this function with any output data to be passed to the readable interface. ",
                      "name": "outputFn",
                      "type": "Function",
                      "desc": "Call this function with any output data to be passed to the readable interface."
                    },
                    {
                      "textRaw": "`callback` {Function} Call this function (optionally with an error argument) when you are done flushing any remaining data. ",
                      "name": "callback",
                      "type": "Function",
                      "desc": "Call this function (optionally with an error argument) when you are done flushing any remaining data."
                    }
                  ]
                },
                {
                  "params": [
                    {
                      "name": "outputFn"
                    },
                    {
                      "name": "callback"
                    }
                  ]
                }
              ],
              "desc": "<p>Note: <strong>This function MUST NOT be called directly.</strong>  It MAY be implemented\nby child classes, and if so, will be called by the internal Transform\nclass methods only.\n\n</p>\n<p>In some cases, your transform operation may need to emit a bit more\ndata at the end of the stream.  For example, a <code>Zlib</code> compression\nstream will store up some internal state so that it can optimally\ncompress the output.  At the end, however, it needs to do the best it\ncan with what is left, so that the data will be complete.\n\n</p>\n<p>In those cases, you can implement a <code>_flush</code> method, which will be\ncalled at the very end, after all the written data is consumed, but\nbefore emitting <code>end</code> to signal the end of the readable side.  Just\nlike with <code>_transform</code>, call <code>outputFn</code> zero or more times, as\nappropriate, and call <code>callback</code> when the flush operation is complete.\n\n</p>\n<p>This method is prefixed with an underscore because it is internal to\nthe class that defines it, and should not be called directly by user\nprograms.  However, you <strong>are</strong> expected to override this method in\nyour own extension classes.\n\n\n</p>\n"
            }
          ]
        },
        {
          "textRaw": "Class: stream.PassThrough",
          "type": "class",
          "name": "stream.PassThrough",
          "desc": "<p>This is a trivial implementation of a <code>Transform</code> stream that simply\npasses the input bytes across to the output.  Its purpose is mainly\nfor examples and testing, but there are occasionally use cases where\nit can come in handy.\n\n\n</p>\n"
        }
      ],
      "type": "module",
      "displayName": "Stream"
    }
  ]
}
